import * as os from "os";
import * as fs from "fs/promises";
import { existsSync, mkdtempSync } from "fs";
import * as path from "path";
import execa from "execa";

export class Monorepo {
  static tmpdir = os.tmpdir();

  root: string;

  get nodeModulesPath() {
    return path.join(this.root, "node_modules");
  }

  constructor(private name: string) {
    this.root = mkdtempSync(path.join(Monorepo.tmpdir, `monorepo-fixture-${name}-`));
  }

  async init(fixturePath?: string) {
    const options = { cwd: this.root };
    const cwd = this.root;
    await execa("git", ["init"], options);
    await execa("git", ["config", "user.email", "you@example.com"], options);
    await execa("git", ["config", "user.name", "test user"], options);
    await execa("git", ["config", "commit.gpgsign", "false"], options);

    if (fixturePath) {
      await fs.mkdir(this.root, { recursive: true });
      await fs.cp(fixturePath, this.root, { recursive: true });

      execa.sync("git", ["add", "."], { cwd });
      execa.sync("git", ["commit", "-m", "test"], { cwd });
    } else {
      await this.generateRepoFiles();
    }
  }

  async install() {
    if (!existsSync(this.nodeModulesPath)) {
      await fs.mkdir(this.nodeModulesPath, { recursive: true });
    }

    // pretends to perform a npm install of lage
    const lagePath = path.join(this.nodeModulesPath, "lage");

    if (!existsSync(lagePath)) {
      await fs.symlink(path.join(__dirname, "..", ".."), lagePath, "junction");
    }
  }

  /**
   * Simulates a "yarn" call by linking internal packages and generates a yarn.lock file
   */
  async linkPackages() {
    const pkgs = await fs.readdir(path.join(this.root, "packages"));

    if (!existsSync(this.nodeModulesPath)) {
      await fs.mkdir(this.nodeModulesPath, { recursive: true });
    }

    let yarnYaml = `# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.\n# yarn lockfile v1\n`;

    for (const pkg of pkgs) {
      await fs.symlink(path.join(this.root, "packages", pkg), path.join(this.nodeModulesPath, pkg), "junction");

      const pkgJson = JSON.parse(await fs.readFile(path.join(this.root, "packages", pkg, "package.json"), "utf-8"));
      const deps = pkgJson.dependencies;

      yarnYaml += `"${pkg}@^${pkgJson.version}":\n  version "${pkgJson.version}"\n`;

      if (deps) {
        yarnYaml += `  dependencies:`;
        for (const dep of Object.keys(deps)) {
          yarnYaml += `    "${dep}" "0.1.0"`;
        }
      }
    }

    await this.commitFiles({ "yarn.lock": yarnYaml });
  }

  async generateRepoFiles() {
    const lagePath = path.join(this.nodeModulesPath, "lage/lib/cli");

    await this.commitFiles({
      "package.json": {
        name: this.name,
        version: "0.1.0",
        private: true,
        workspaces: ["packages/*"],
        scripts: {
          bundle: `node "${lagePath}" bundle --reporter json --log-level silly`,
          transpile: `node "${lagePath}" transpile --reporter json --log-level silly`,
          build: `node "${lagePath}" build --reporter json --log-level silly`,
          writeInfo: `node "${lagePath}" info`,
          test: `node "${lagePath}" test --reporter json --log-level silly`,
          lint: `node "${lagePath}" lint --reporter json --log-level silly`,
          clear: `node "${lagePath}" cache --clear --reporter json --log-level silly`,
        },
        devDependencies: {
          lage: path.resolve(__dirname, "..", ".."),
        },
      },
      "lage.config.js": `module.exports = {
        pipeline: {
          build: ['^build'],
          test: ['build'],
          lint: []
        }
      };`,
      ".gitignore": "node_modules",
    });
  }

  async setLageConfig(contents: string) {
    await this.commitFiles({
      "lage.config.js": contents,
    });
  }

  async addPackage(name: string, internalDeps: string[] = [], scripts?: { [script: string]: string }) {
    return await this.commitFiles({
      [`packages/${name}/build.js`]: `console.log('building ${name}');`,
      [`packages/${name}/test.js`]: `console.log('building ${name}');`,
      [`packages/${name}/lint.js`]: `console.log('linting ${name}');`,
      [`packages/${name}/package.json`]: {
        name,
        version: "0.1.0",
        scripts: scripts || {
          build: "node ./build.js",
          test: "node ./test.js",
          lint: "node ./lint.js",
        },
        dependencies: {
          ...(internalDeps &&
            internalDeps.reduce((deps, dep) => {
              return { ...deps, [dep]: "*" };
            }, {})),
        },
      },
    });
  }

  clone(origin: string) {
    return execa("git", ["clone", origin], { cwd: this.root });
  }

  push(origin: string, branch: string) {
    return execa("git", ["push", origin, branch], { cwd: this.root });
  }

  async writeFiles(files: { [file: string]: string | object }, options: { executable?: boolean } = {}) {
    for (const [file, contents] of Object.entries(files)) {
      let out = "";
      if (typeof contents !== "string") {
        out = JSON.stringify(contents, null, 2);
      } else {
        out = contents;
      }

      const fullPath = path.join(this.root, file);

      if (!existsSync(path.dirname(fullPath))) {
        await fs.mkdir(path.dirname(fullPath), { recursive: true });
      }

      await fs.writeFile(fullPath, out);

      if (options.executable) {
        await fs.chmod(path.join(this.root, file), 0o755);
      }
    }
  }

  async readFiles(files: string[]) {
    const contents = {};
    for (const file of files) {
      const fullPath = path.join(this.root, file);
      if (!existsSync(fullPath)) {
        throw new Error(`File ${fullPath} does not exist`);
      }
      contents[file] = await fs.readFile(fullPath, "utf-8");
    }

    return contents;
  }

  async commitFiles(files: { [name: string]: string | object }, options: { executable?: boolean } = {}) {
    await this.writeFiles(files, options);
    await execa("git", ["add", "--", ...Object.keys(files)], {
      cwd: this.root,
    });
    await execa("git", ["commit", "-m", "commit files"], { cwd: this.root });
  }

  run(command: string, args?: string[], silent?: boolean) {
    return execa("yarn", [...(silent === true ? ["--silent"] : []), command, ...(args || [])], {
      cwd: this.root,
    });
  }

  cleanup() {
    return fs.rm(this.root, { recursive: true });
  }
}
